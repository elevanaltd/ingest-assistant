# ADR-007: Video Analysis Workflow Implementation

**Status:** PROPOSED
**Date:** 2025-01-06
**Authors:** Holistic Orchestrator, User
**Deciders:** User (EAV team)

---

## Context

The Ingest Assistant currently supports AI-powered analysis and metadata generation for **photos only**. However, the primary use case involves **video footage** which presents unique architectural challenges:

### Current Photo Workflow (Working)
```
1. Import photos to LucidLink
2. Electron app analyzes full image files
3. AI generates metadata (name, keywords)
4. Metadata written to file via exiftool
5. Import to Premiere Pro → metadata visible
```

### Video Constraints (Challenges)
1. **File Size:** Raw video files are 1.5-2GB (too large for quick analysis)
2. **Storage Architecture:**
   - Raw files → Ubuntu Server (restricted access, offline in PP)
   - Proxies → LucidLink (universal access, 100-150MB)
3. **Premiere Pro Behavior:**
   - Reads metadata from RAW file, not proxy
   - When raw is offline, only **Tape Name** and **Description** survive
   - Name field shows filename (e.g., "C0001.MOV") not description
4. **Linking Mechanism:** Tape Name field enables proxy↔raw linking even after renames

### Business Requirements
- Editors need descriptive names visible in PP project panel
- Metadata must be searchable when raw footage is offline
- Process must work without requiring all users to access Ubuntu Server
- Workflow should be faster than current manual cataloging

---

## Decision

Implement **proxy-based video analysis with dual metadata write** and **PP Name field automation**.

### Architecture: Three-Phase Pipeline

```
┌─────────────────────────────────────────────────────────┐
│ PHASE 1: PROXY CREATION & ANALYSIS                      │
├─────────────────────────────────────────────────────────┤
│ 1. Export raw → Ubuntu Server                           │
│ 2. Create proxies → LucidLink (external or PP)          │
│ 3. Electron app analyzes proxies (frame extraction)     │
│ 4. AI generates Tape Name + Description                 │
│ 5. Write metadata to BOTH proxy AND raw files           │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ PHASE 2: PREMIERE PRO IMPORT                            │
├─────────────────────────────────────────────────────────┤
│ 6. Import raw to PP project                             │
│ 7. Attach proxies (links via Tape Name)                 │
│ 8. PP reads metadata from raw:                          │
│    - Tape Name = C0001                                  │
│    - Description = "microwave, siemens, controls"       │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ PHASE 3: NAME FIELD UPDATE (CRITICAL)                   │
├─────────────────────────────────────────────────────────┤
│ 9. Run ExtendScript (generated by Electron app)         │
│ 10. Script updates PP project item Name field:          │
│     - Reads Description from metadata                   │
│     - Sets Name = Description                           │
│ 11. Editors see: "microwave, siemens, controls"         │
│     (not "C0001.MOV")                                   │
└─────────────────────────────────────────────────────────┘
```

### Key Design Decisions

**1. Frame Extraction for AI Analysis**
- Extract 5 frames per video (at 10%, 30%, 50%, 70%, 90%)
- Analyze frames with AI vision API (same as photos)
- **Rationale:** AI can't watch full video anyway; samples sufficient for metadata generation

**2. Dual Metadata Write (Proxy + Raw)**
- Write to proxy on LucidLink (universal access)
- Write to raw on Ubuntu Server (via path mapping)
- **Rationale:** PP reads from raw, but users can only easily access proxies

**3. Metadata Fields (Offline-Safe)**
- **Tape Name:** Original filename (e.g., "C0001") → Preserves proxy linking
- **Description:** AI-generated descriptive text → Survives offline, searchable
- **No Keywords:** Disappears when raw goes offline in PP
- **Rationale:** Only use fields that survive when raw is offline

**4. PP Name Field Automation (ExtendScript)**
- Electron app generates ExtendScript (.jsx) after analysis
- Script batch-renames all project items: Name = Description
- **Rationale:** Editors see descriptive names in default column, not filenames

---

## Implementation Plan

### Phase 1: Core Video Analysis (Foundation)

**Component: Video Frame Extractor**
```typescript
// electron/services/videoFrameExtractor.ts
export class VideoFrameExtractor {
  /**
   * Extract frames from video at specified timestamps
   * Uses ffmpeg (bundled with Electron app)
   */
  async extractFrames(
    videoPath: string,
    timestamps: number[]
  ): Promise<string[]> {
    const frames: string[] = [];

    for (const timestamp of timestamps) {
      const outputPath = await this.extractSingleFrame(
        videoPath,
        timestamp
      );
      frames.push(outputPath);
    }

    return frames;
  }

  private async extractSingleFrame(
    videoPath: string,
    timestamp: number
  ): Promise<string> {
    // timestamp: 0.1 = 10% through video
    const duration = await this.getVideoDuration(videoPath);
    const seconds = duration * timestamp;

    const outputPath = path.join(
      tmpdir(),
      `frame-${Date.now()}-${timestamp}.jpg`
    );

    await execAsync(
      `ffmpeg -ss ${seconds} -i "${videoPath}" -frames:v 1 "${outputPath}"`
    );

    return outputPath;
  }

  private async getVideoDuration(videoPath: string): Promise<number> {
    const { stdout } = await execAsync(
      `ffprobe -v error -show_entries format=duration ` +
      `-of default=noprint_wrappers=1:nokey=1 "${videoPath}"`
    );
    return parseFloat(stdout.trim());
  }
}
```

**Component: AI Service Enhancement**
```typescript
// electron/services/aiService.ts (UPDATE)
export class AIService {
  // EXISTING: analyzeImage(imagePath, lexicon)

  /**
   * Analyze video by extracting and analyzing frames
   * NEW METHOD
   */
  async analyzeVideo(
    videoPath: string,
    lexicon: Lexicon
  ): Promise<AIAnalysisResult> {
    // 1. Extract frames
    const frameExtractor = new VideoFrameExtractor();
    const framePaths = await frameExtractor.extractFrames(
      videoPath,
      [0.1, 0.3, 0.5, 0.7, 0.9] // Config-driven timestamps
    );

    // 2. Analyze each frame
    const frameAnalyses = await Promise.all(
      framePaths.map(frame => this.analyzeImage(frame, lexicon))
    );

    // 3. Synthesize results (combine frame analyses)
    const synthesized = this.synthesizeFrameAnalyses(frameAnalyses);

    // 4. Cleanup temp frames
    await Promise.all(framePaths.map(f => fs.unlink(f)));

    return synthesized;
  }

  private synthesizeFrameAnalyses(
    analyses: AIAnalysisResult[]
  ): AIAnalysisResult {
    // Combine multiple frame analyses into single result
    // Strategy: Most common terms, highest confidence

    const allNames = analyses.map(a => a.mainName);
    const allMetadata = analyses.flatMap(a => a.metadata);
    const avgConfidence = analyses.reduce((sum, a) => sum + a.confidence, 0) / analyses.length;

    return {
      mainName: this.selectBestName(allNames),
      metadata: this.consolidateMetadata(allMetadata),
      confidence: avgConfidence
    };
  }
}
```

**Component: File Type Detection**
```typescript
// electron/services/fileManager.ts (UPDATE)
export class FileManager {
  private readonly VIDEO_EXTENSIONS = [
    '.mp4', '.mov', '.avi', '.webm', '.mkv', '.m4v'
  ];

  getFileType(filePath: string): 'image' | 'video' {
    const ext = path.extname(filePath).toLowerCase();

    if (this.VIDEO_EXTENSIONS.includes(ext)) {
      return 'video';
    }

    return 'image'; // Default to image for existing photo support
  }

  async scanFolder(folderPath: string): Promise<FileMetadata[]> {
    // EXISTING: Scan for images
    // NEW: Also detect videos

    const files = await fs.readdir(folderPath);
    const metadata: FileMetadata[] = [];

    for (const file of files) {
      const filePath = path.join(folderPath, file);
      const stats = await fs.stat(filePath);

      if (stats.isFile()) {
        const fileType = this.getFileType(filePath);

        // Include both images AND videos
        if (fileType === 'image' || fileType === 'video') {
          metadata.push({
            id: this.extractFileId(file),
            fileType,
            filePath,
            // ... rest of metadata
          });
        }
      }
    }

    return metadata;
  }
}
```

---

### Phase 2: Dual Metadata Write with Path Mapping

**Component: Path Mapping Configuration**
```typescript
// electron/services/pathMapper.ts (NEW)
export class PathMapper {
  constructor(private config: PathMappingConfig) {}

  /**
   * Map proxy file path to raw file path
   * Example:
   *   Proxy: /Volumes/videos-current/.../Video (Proxy)/EA000296_Proxy.mov
   *   Raw:   /Volumes/EAV_Video_RAW/.../EA000296.MOV
   */
  mapProxyToRaw(proxyPath: string): string | null {
    // Extract base filename (remove _Proxy suffix)
    const proxyFilename = path.basename(proxyPath);
    const baseFilename = proxyFilename.replace(/_Proxy\.mov$/i, '.MOV');

    // Search for raw file in configured raw root
    const rawPath = this.findFileInTree(
      this.config.rawRoot,
      baseFilename
    );

    return rawPath;
  }

  private findFileInTree(
    rootDir: string,
    filename: string
  ): string | null {
    // Recursive search (with depth limit for performance)
    // Returns first match or null

    const search = (dir: string, depth: number): string | null => {
      if (depth > 10) return null; // Prevent infinite loops

      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isFile() && entry.name === filename) {
          return fullPath;
        }

        if (entry.isDirectory()) {
          const result = search(fullPath, depth + 1);
          if (result) return result;
        }
      }

      return null;
    };

    return search(rootDir, 0);
  }
}
```

**Component: Dual Metadata Writer**
```typescript
// electron/services/configManager.ts (UPDATE)
export class ConfigManager {
  // NEW: Path mapping config
  getPathMapping(): PathMappingConfig {
    return {
      proxyRoot: this.config.get('videoPaths.proxyRoot') ||
                 '/Volumes/videos-current/',
      rawRoot: this.config.get('videoPaths.rawRoot') ||
               '/Volumes/EAV_Video_RAW/',
      proxyPattern: this.config.get('videoPaths.proxyPattern') ||
                    '{filename}_Proxy.mov',
      rawPattern: this.config.get('videoPaths.rawPattern') ||
                  '{filename}.MOV'
    };
  }
}

// electron/main.ts (UPDATE IPC handler)
ipcMain.handle('ai:analyze-file', async (_event, filePath: string) => {
  const fileManager = new FileManager();
  const fileType = fileManager.getFileType(filePath);
  const lexicon = await configManager.getLexicon();

  let result: AIAnalysisResult;

  if (fileType === 'video') {
    result = await aiService.analyzeVideo(filePath, lexicon);
  } else {
    result = await aiService.analyzeImage(filePath, lexicon);
  }

  return result;
});

ipcMain.handle('file:update-metadata', async (_event, fileId, metadata) => {
  const fileManager = new FileManager();
  const currentFile = await fileManager.getFileById(fileId);

  // Build metadata object with Tape Name
  const metadataObj = {
    tapeName: extractTapeName(currentFile.originalFilename),
    description: metadata.join(', '), // AI-generated tags as description
  };

  // Write to current file (proxy on LucidLink)
  await metadataWriter.writeMetadataToFile(
    currentFile.filePath,
    metadataObj
  );

  // If video, also write to raw file
  if (currentFile.fileType === 'video') {
    const pathMapper = new PathMapper(configManager.getPathMapping());
    const rawPath = pathMapper.mapProxyToRaw(currentFile.filePath);

    if (rawPath && await fs.pathExists(rawPath)) {
      await metadataWriter.writeMetadataToFile(rawPath, metadataObj);
    } else {
      // Queue for batch write later (export CSV for manual processing)
      console.warn(`Raw file not accessible: ${rawPath}`);
    }
  }

  return true;
});
```

**Component: Tape Name Extraction**
```typescript
// electron/utils/tapeNameExtractor.ts (NEW)
export function extractTapeName(filename: string): string {
  /**
   * Extract original filename as Tape Name (without extension)
   * Examples:
   *   EA000296.MOV → EA000296
   *   EA000296_Proxy.mov → EA000296
   *   C0001.MOV → C0001
   */
  const baseName = path.basename(filename, path.extname(filename));

  // Remove _Proxy suffix if present
  return baseName.replace(/_Proxy$/i, '');
}
```

---

### Phase 3: ExtendScript Generation

**Component: PP Script Generator**
```typescript
// electron/services/ppScriptGenerator.ts (NEW)
export class PPScriptGenerator {
  /**
   * Generate ExtendScript to batch-rename PP project items
   * Sets Name field = Description from metadata
   */
  generateRenameScript(files: FileMetadata[]): string {
    const metadataMap = files.reduce((map, file) => {
      const tapeName = extractTapeName(file.originalFilename);
      map[tapeName] = file.mainName; // Use AI-generated main name
      return map;
    }, {} as Record<string, string>);

    return `
// Ingest Assistant - Batch Rename PP Items
// Generated: ${new Date().toISOString()}

var project = app.project;
if (!project) {
  alert("No active project. Please open a project first.");
} else {
  renameItems();
}

function renameItems() {
  var metadata = ${JSON.stringify(metadataMap, null, 2)};

  var renamedCount = 0;
  var totalCount = project.rootItem.children.numItems;

  for (var i = 0; i < totalCount; i++) {
    var item = project.rootItem.children[i];

    // Get Tape Name from item metadata
    var tapeName = getMetadataValue(item, "Tape Name");

    if (tapeName && metadata[tapeName]) {
      var newName = metadata[tapeName];
      item.name = newName;
      renamedCount++;
    }
  }

  alert("Renamed " + renamedCount + " of " + totalCount + " items.");
}

function getMetadataValue(item, fieldName) {
  try {
    var metadata = item.getProjectMetadata();
    // Parse XMP metadata to extract field
    // (PP-specific XMP parsing logic)
    return extractFieldFromXMP(metadata, fieldName);
  } catch (e) {
    return null;
  }
}

function extractFieldFromXMP(xmp, fieldName) {
  // Simplified: Extract from XMP string
  var pattern = new RegExp('<dc:' + fieldName.replace(' ', '') + '>(.*?)</dc:' + fieldName.replace(' ', '') + '>');
  var match = xmp.match(pattern);
  return match ? match[1] : null;
}
`;
  }

  async saveScript(script: string, outputPath: string): Promise<void> {
    await fs.writeFile(outputPath, script, 'utf-8');
  }
}

// electron/main.ts (ADD IPC handler)
ipcMain.handle('pp:generate-rename-script', async (_event, folderPath) => {
  const fileManager = new FileManager();
  const files = await fileManager.scanFolder(folderPath);

  const generator = new PPScriptGenerator();
  const script = generator.generateRenameScript(files);

  const scriptPath = path.join(
    app.getPath('desktop'),
    'pp-rename-items.jsx'
  );

  await generator.saveScript(script, scriptPath);

  return scriptPath;
});
```

**UI Component: Export Script Button**
```typescript
// src/App.tsx (ADD button)
const handleExportPPScript = async () => {
  if (!folderPath) {
    setStatusMessage('✗ No folder selected');
    return;
  }

  setIsLoading(true);
  try {
    const scriptPath = await window.electronAPI.generatePPScript(folderPath);
    setStatusMessage(`✓ PP script saved to: ${scriptPath}`);
  } catch (error) {
    setStatusMessage('✗ Failed to generate PP script');
  } finally {
    setIsLoading(false);
  }
};

// Add button to UI
<button
  onClick={handleExportPPScript}
  className="btn-secondary"
  disabled={!folderPath || files.length === 0}
>
  Export PP Rename Script
</button>
```

---

## Configuration

### Application Config (config.yaml)

```yaml
# Video analysis settings
videoPaths:
  # Where proxies are stored (accessible to all users via LucidLink)
  proxyRoot: /Volumes/videos-current/2. WORKING PROJECTS/

  # Where raw footage is stored (Ubuntu Server, access via SMB or script)
  rawRoot: /Volumes/EAV_Video_RAW/

  # File naming patterns
  proxyPattern: "{filename}_Proxy.mov"
  rawPattern: "{filename}.MOV"

videoAnalysis:
  # Frame extraction settings
  frameSampleCount: 5
  frameSamplePoints: [0.1, 0.3, 0.5, 0.7, 0.9]  # Percentages through video

  # Metadata fields (only fields that survive offline in PP)
  metadataFields:
    - tapeName     # Original filename for proxy linking
    - description  # AI-generated description (survives offline)

  # ExtendScript generation
  ppScript:
    enabled: true
    outputPath: ~/Desktop/pp-rename-items.jsx
    autoOpen: false  # Open script after generation

# Existing lexicon config
lexicon:
  preferredTerms: [...]
  excludedTerms: [...]
  # etc.
```

### Environment Variables (Optional)

```bash
# .env (if not using config.yaml)
VIDEO_PROXY_ROOT=/Volumes/videos-current/2. WORKING PROJECTS/
VIDEO_RAW_ROOT=/Volumes/EAV_Video_RAW/
VIDEO_FRAME_COUNT=5
```

### PP Script Installation

**Location:** Save generated scripts to:
```
~/Desktop/pp-rename-items.jsx  (default)
# OR
/Applications/Adobe Premiere Pro 2024/Scripts/pp-rename-items.jsx
```

**Usage in PP:**
1. Import raw footage and attach proxies
2. File → Scripts → Run Script → Select `pp-rename-items.jsx`
3. Script updates Name field for all items

---

## Dependencies

### New Dependencies Required

**ffmpeg (Bundled with Electron)**
```json
// package.json
{
  "dependencies": {
    "@ffmpeg-installer/ffmpeg": "^1.1.0",
    "@ffprobe-installer/ffprobe": "^1.4.1"
  }
}
```

**Usage:**
```typescript
import ffmpeg from '@ffmpeg-installer/ffmpeg';
import ffprobe from '@ffprobe-installer/ffprobe';

const ffmpegPath = ffmpeg.path;
const ffprobePath = ffprobe.path;
```

### Existing Dependencies (No Changes)
- `keytar` (Keychain integration)
- `electron-store` (Config storage)
- `exiftool` (Metadata writing)
- `openai` / `anthropic` (AI APIs)

---

## Testing Strategy

### Phase 1: Unit Tests (Frame Extraction)

```typescript
// electron/services/videoFrameExtractor.test.ts
describe('VideoFrameExtractor', () => {
  it('should extract frames at specified timestamps', async () => {
    const extractor = new VideoFrameExtractor();
    const frames = await extractor.extractFrames(
      '/path/to/test-video.mp4',
      [0.1, 0.5, 0.9]
    );

    expect(frames).toHaveLength(3);
    expect(await fs.pathExists(frames[0])).toBe(true);
  });

  it('should get video duration correctly', async () => {
    const extractor = new VideoFrameExtractor();
    const duration = await extractor['getVideoDuration'](
      '/path/to/test-video.mp4'
    );

    expect(duration).toBeGreaterThan(0);
  });
});
```

### Phase 2: Integration Tests (AI Analysis)

```typescript
// electron/services/aiService.test.ts
describe('AIService - Video Analysis', () => {
  it('should analyze video and generate metadata', async () => {
    const aiService = new AIService('openrouter', 'model', 'key');
    const result = await aiService.analyzeVideo(
      '/path/to/test-video.mp4',
      mockLexicon
    );

    expect(result.mainName).toBeTruthy();
    expect(result.metadata).toBeInstanceOf(Array);
    expect(result.confidence).toBeGreaterThan(0);
  });
});
```

### Phase 3: E2E Tests (Full Workflow)

```typescript
// electron/__tests__/e2e/video-workflow.test.ts
describe('Video Workflow E2E', () => {
  it('should process video from analysis to PP script', async () => {
    // 1. Scan folder with video files
    const files = await fileManager.scanFolder('/test/videos/');
    expect(files.some(f => f.fileType === 'video')).toBe(true);

    // 2. Analyze video
    const videoFile = files.find(f => f.fileType === 'video');
    const analysis = await aiService.analyzeVideo(
      videoFile.filePath,
      lexicon
    );

    // 3. Write metadata to proxy
    await metadataWriter.writeMetadataToFile(
      videoFile.filePath,
      { tapeName: 'C0001', description: analysis.mainName }
    );

    // 4. Generate PP script
    const script = ppScriptGenerator.generateRenameScript([videoFile]);
    expect(script).toContain('C0001');
    expect(script).toContain(analysis.mainName);
  });
});
```

### Manual Testing Checklist

**Prerequisites:**
- [ ] Sample proxy video file on LucidLink
- [ ] Sample raw video file on Ubuntu Server (or local for testing)
- [ ] AI API key configured

**Test 1: Frame Extraction**
- [ ] Select folder with video file
- [ ] Click video in sidebar
- [ ] Verify app can extract frames (check temp directory)
- [ ] Frames should be ~5 JPG files

**Test 2: AI Analysis**
- [ ] Click "AI Assist" on video file
- [ ] Verify AI generates description
- [ ] Check confidence score
- [ ] Compare quality to photo analysis

**Test 3: Dual Metadata Write**
- [ ] Save metadata from analyzed video
- [ ] Verify Tape Name written to proxy file (exiftool -TapeName proxy.mov)
- [ ] Verify Description written to proxy file
- [ ] If raw accessible: verify same metadata written to raw

**Test 4: PP Integration**
- [ ] Import raw video to PP
- [ ] Attach proxy
- [ ] Verify Tape Name visible in PP metadata panel
- [ ] Verify Description visible
- [ ] Take raw offline → verify Tape Name + Description survive

**Test 5: ExtendScript**
- [ ] Generate PP script from analyzed folder
- [ ] Open PP project with imported videos
- [ ] Run script: File → Scripts → Run Script
- [ ] Verify Name field updated to Description
- [ ] Verify editors see descriptive names, not filenames

---

## Rollout Plan

### Week 1: Core Implementation
- [ ] Add ffmpeg dependencies
- [ ] Implement VideoFrameExtractor
- [ ] Update AIService with analyzeVideo method
- [ ] Update FileManager to detect video files
- [ ] Add unit tests

### Week 2: Metadata & Mapping
- [ ] Implement PathMapper
- [ ] Add dual metadata write logic
- [ ] Add Tape Name extraction utility
- [ ] Update IPC handlers for video support
- [ ] Add integration tests

### Week 3: PP Integration
- [ ] Implement PPScriptGenerator
- [ ] Add UI button for script export
- [ ] Test ExtendScript in PP
- [ ] Add E2E tests
- [ ] Documentation updates

### Week 4: Testing & Validation
- [ ] Manual testing with real footage
- [ ] Validate metadata survival when raw offline
- [ ] Test proxy linking after renames
- [ ] User acceptance testing with editors
- [ ] Performance optimization

### Week 5: Deployment
- [ ] Build production DMG with ffmpeg bundled
- [ ] Create user guide (video workflow)
- [ ] Train team on new workflow
- [ ] Monitor for issues
- [ ] Iterate based on feedback

---

## Consequences

### Positive

1. **Video analysis capability unlocked**
   - AI can generate metadata for video footage
   - Same quality as photo analysis (samples frames)
   - Faster than manual cataloging

2. **Dual metadata write solves offline problem**
   - Metadata written to both proxy and raw
   - PP reads from raw → metadata visible
   - Tape Name + Description survive offline

3. **Editor UX dramatically improved**
   - Name field shows descriptions, not filenames
   - One-click batch rename via ExtendScript
   - Searchable metadata in PP

4. **Workflow flexibility**
   - Works with proxies on LucidLink (universal access)
   - Doesn't require all users to access Ubuntu
   - Can analyze before or after PP import

5. **Maintains proxy linking**
   - Tape Name field preserves link
   - Files can be renamed without breaking link
   - Original filename preserved as metadata

### Negative

1. **Additional complexity**
   - Frame extraction adds processing step
   - Path mapping requires configuration
   - ExtendScript adds manual step (for now)

2. **ffmpeg dependency**
   - Increases app bundle size (~50MB)
   - Platform-specific binaries needed
   - Potential compatibility issues

3. **Ubuntu Server access challenge**
   - Dual write requires network access to raw files
   - May need Mac Mini as intermediary
   - Batch write fallback for limited access scenarios

4. **PP workflow change**
   - New step: Run ExtendScript after import
   - Could be automated in future UXP panel
   - Requires training for team

### Risks & Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Frame extraction fails | High | Low | Fallback to first frame only, error handling |
| Path mapping incorrect | High | Medium | Configuration validation, manual override option |
| Raw file inaccessible | Medium | Medium | Batch export CSV for later manual write |
| ExtendScript fails | Medium | Low | Include error handling, fallback to manual rename |
| ffmpeg compatibility | Low | Medium | Test on multiple platforms, include troubleshooting guide |

---

## Alternatives Considered

### Alternative 1: UXP Panel (Future)
**Approach:** Build Premiere Pro panel instead of Electron app
**Pros:** No ExtendScript needed, direct Name field update, in-context workflow
**Cons:** Different architecture, learning curve, doesn't help with photo workflow
**Decision:** Defer to future; validate Electron approach first

### Alternative 2: Proxy-Only Metadata
**Approach:** Write metadata only to proxies, not raw files
**Pros:** Simpler, no Ubuntu access needed, faster
**Cons:** Metadata not visible in PP when raw offline
**Decision:** Rejected; doesn't solve core editor UX problem

### Alternative 3: Analyze Raw Files
**Approach:** Give all users Ubuntu access, analyze raw files directly
**Pros:** No proxy/raw mapping needed, single source of truth
**Cons:** 1.5-2GB files too slow, access control issues, network overhead
**Decision:** Rejected; proxy analysis is faster and more practical

### Alternative 4: Manual PP Rename Workflow
**Approach:** Skip ExtendScript, editors manually rename in PP
**Pros:** No script generation, simpler implementation
**Cons:** Tedious for large projects, defeats automation purpose
**Decision:** Rejected; automation is key value proposition

---

## References

- [Premiere Pro ExtendScript Guide](https://ppro-scripting.docsforadobe.dev/)
- [exiftool Video Metadata](https://exiftool.org/TagNames/QuickTime.html)
- [FFmpeg Documentation](https://ffmpeg.org/ffmpeg.html)
- [ADR-006: Security Hardening Strategy](./001-DOC-ADR-006-SECURITY-HARDENING-STRATEGY.md)
- [Electron App Architecture](../001-DOC-ARCHITECTURE.md)

---

## Appendix: Sample Metadata Structure

### Video File Metadata (After Analysis)

```json
{
  "id": "EA000296",
  "originalFilename": "EA000296.MOV",
  "currentFilename": "EA000296_Proxy.mov",
  "fileType": "video",
  "filePath": "/Volumes/videos-current/.../EA000296_Proxy.mov",
  "mainName": "microwave, siemens, controls",
  "metadata": [
    "microwave",
    "siemens",
    "controls",
    "kitchen",
    "appliance"
  ],
  "processedByAI": true,
  "tapeName": "EA000296",
  "description": "microwave, siemens, controls"
}
```

### EXIF Metadata (Written to Files)

```bash
# Read with exiftool
$ exiftool EA000296_Proxy.mov

TapeName        : EA000296
Description     : microwave, siemens, controls
```

### PP Project Item (After Import + Script)

```
Name:          microwave, siemens, controls  (after ExtendScript)
Tape Name:     EA000296
Description:   microwave, siemens, controls
Media Path:    /Volumes/EAV_Video_RAW/.../EA000296.MOV (offline)
Proxy Path:    /Volumes/videos-current/.../EA000296_Proxy.mov (online)
```

---

**END OF ADR-007**
